# Client Subscribe Message

Sent by client to server right after establishing a connection. New clients must authenticate themselves when
subscribing to any blockchain events via a signature.

## Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "type": {
      "type": "string",
      "enum": [
        "subscribe"
      ]
    },
    "topic": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "blockchain": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "network": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "network"
            ]
          },
          "publicKey": {
            "type": "string",
            "pattern": "^[A-Za-z0-9+/=]*$"
          },
          "signature": {
            "type": "string",
            "pattern": "^[A-Za-z0-9+/=]*$"
          },
          /* <blockchain specific grouped fields> */
          "cardano": {
            "type": "object",
            "properties": {
              "credentials": {
                "type": "object",
                "properties": {
                  "payment": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "pattern": "^[A-Za-z0-9+/=]*$"
                    }
                  },
                  "stake": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "pattern": "^[A-Za-z0-9+/=]*$"
                    }
                  }
                },
                "required": [
                  "payment",
                  "stake"
                ]
              },
              "config": {
                "type": "object",
                "properties": {
                  "resolveTxInput": {
                    "type": "boolean",
                    "default": false
                  },
                  "assetMetadata": {
                    "type": "boolean",
                    "default": false
                  }
                }
              },
              "points": {
                "type": "array",
                "properties": {
                  "slot": {
                    "type": "integer",
                    "minimum": 0
                  },
                  "hash": {
                    "type": "string",
                    "pattern": "^[A-Za-z0-9+/=]*$"
                  }
                },
                "required": [
                  "slot",
                  "hash"
                ]
              }
            },
            "required": [
              "credentials",
              "config",
              "points"
            ]
          }
        },
        "required": [
          "blockchain",
          "publicKey",
          "signature"
        ]
      }
    },
    "timestamp": {
      "type": "string",
      "format": "date-time"
    }
  },
  "required": [
    "type",
    "topics",
    "timestamp"
  ],
  "additionalProperties": false
}
```

The `signature` field is generated by signing a SHA256 HMAC hashed string. The prehash string is constructed by
concatenating the subscribed `blockchains` + `timestamp`.

> [!NOTE]
> For subscribing to multiple blockchains, the prehash string must be generated for each
> as `<blockchain.name>.<blockchain.network>`, for example:
> `cardano.mainnet+2024-06-27T12:34:56Z`.

Apply a SHA256 HMAC using either the payment signing key or staking signing key, and then base64-encode it as final
payload within the initial message. Pass the output of this SHA256 HMAC to the signature field.

The signature verifies ownership of the private key, whose corresponding public key is used to filter relevant block
transactions.

## Subscribe Example

```json
{
  "type": "subscribe",
  "topic": {
    "blockchain": {
      "name": "cardano",
      "network": "mainnet"
    },
    "publicKey": "publicKey_example",
    "signature": "OGNiOWIyNGVjOTMxZmY3N2MzYjQxOTY3OWE0YTcwMzczZmVkZmIxNDZmMDE0ODk0Nzg4YjUxMmIzMjE4MDdiYw==",
    // base64, SHA256 HMAC with your signing key
    "cardano": {
      "credentials": {
        "payment": [
          "script...",
          "addr_vkh..."
        ],
        // this field follows CIP-0005
        "stake": [
          "script...",
          "addr_vkh..."
        ]
        // this field follows CIP-0005
      },
      "points": [
        {
          "slot": 66268628,
          "hash": "47b8ec3a58a4a69cb5e3397c36cb3966913882fa8179cae10a5d3f9319c4ae66"
        },
        {
          "slot": 87868775,
          "hash": "074985b22edc01b9579a2e571dc125e044aecf812ee45d50e6fb6fef979fd0d0"
        }
      ],
      "config": {
        "resolveTxInput": true,
        "assetMetadata": true
      }
    }
  },
  "timestamp": "2024-06-27T12:34:56Z"
}
```

## Subscription Object

The subscription object is blockchain specific, because there are different networks, credentials or other fields
required.
Chain specific fields are grouped under a specific field named after the given chain.
In the case of Cardano blockchain, all the relevant fields are placed under a field named `cardano`.
Below we list the currently supported subscriptions:

### Cardano

This is the format for a Cardano specific object in the `topic` object. A client can subscribe to multiple topics one
after another at any given time.
A client can subscribe to multiple accounts by providing multiple credentials in the `credentials.payment`
or `credentials.stake` array.
The client can provide multiple starting [points](..%2F..%2F01-Stream-api.md#our-protocols-way-of-tracking-time) in the
mandatory `points` array.
The first valid point provided in the array will be used as the starting point. If all the points are invalid, the
subscription will fail.
In case of an empty array, starting point will be the genesis.

```json
{
  "blockchain": {
    "name": "cardano",
    "network": {
      "type": "string",
      "enum": [
        "mainnet",
        "preprod",
        "preview"
      ]
    }
  },
  "publicKey": {
    "type": "string"
  },
  "signature": {
    "type": "string",
    "pattern": "^[A-Za-z0-9+/=]*$"
  },
  "cardano": {
    "type": "object",
    "properties": {
      "credentials": {
        "type": "object",
        "properties": {
          "payment": {
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "^[A-Za-z0-9+/=]*$"
            }
          },
          "stake": {
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "^[A-Za-z0-9+/=]*$"
            }
          }
        },
        "required": [
          "payment",
          "stake"
        ]
      },
      "config": {
        "type": "object",
        "properties": {
          "resolveTxInput": {
            "type": "boolean",
            "default": false
          },
          "assetMetadata": {
            "type": "boolean",
            "default": false
          }
        }
      },
      "points": {
        "type": "array",
        "properties": {
          "slot": {
            "type": "integer",
            "minimum": 0
          },
          "hash": {
            "type": "string",
            "pattern": "^[A-Za-z0-9+/=]*$"
          }
        },
        "required": [
          "slot",
          "hash"
        ]
      }
    },
    "required": [
      "credentials",
      "config",
      "points"
    ]
  },
  "required": [
    "blockchain",
    "publicKey",
    "signature",
    "cardano"
  ]
}
```

### Other blockchains

Any other blockchain schema should follow the same structure as the above Cardano example by applying these:

* Group blockchain specific properties under one property named after the blockchain (see `cardano` field)
* Keep chain specific authentication fields under `credentials` property
* Keep chain specific configuration fields under `config` property
* Keep chain specific starting point fields in `points` array. If not supporting multiple points, use a `point` object.
* Define a JSON Schema in the documentation
